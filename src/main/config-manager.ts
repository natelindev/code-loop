import fs from 'fs';
import path from 'path';
import os from 'os';
import type { AppConfig, ModelConfig } from '../shared/types';

const CONFIG_PATH = path.join(os.homedir(), '.opencode-loop-app.json');
const BASH_CONFIG_PATH = path.join(os.homedir(), '.opencode-loop.conf');

const DEFAULT_MODELS: ModelConfig = {
  modelPlan: 'github-copilot/claude-opus-4.6',
  modelImplement: 'github-copilot/claude-sonnet-4.6',
  modelReview: 'github-copilot/gpt-5.2-codex',
  modelFix: 'github-copilot/claude-sonnet-4.6',
  modelCommit: 'github-copilot/gemini-3-flash-preview',
  modelPr: 'github-copilot/gemini-3-flash-preview',
  modelBranch: 'github-copilot/gemini-3-flash-preview',
};

const DEFAULT_CONFIG: AppConfig = {
  workspaceRoot: path.join(os.homedir(), 'opencode-workspaces'),
  models: { ...DEFAULT_MODELS },
  postCloneCommands: ['pnpm i'],
  maxRetries: 3,
  retryDelays: [10, 30, 60],
  notificationSound: true,
  recentRepos: [],
  scriptPath: '',
};

function resolveScriptPath(): string {
  // Try to find the script relative to this app
  const candidates = [
    path.resolve(__dirname, '../../../scripts/opencode-loop.sh'),
    path.resolve(__dirname, '../../../../scripts/opencode-loop.sh'),
    path.join(os.homedir(), 'custom_scripts/scripts/opencode-loop.sh'),
  ];
  for (const p of candidates) {
    if (fs.existsSync(p)) return p;
  }
  return candidates[0]; // Return first candidate as default
}

export function loadConfig(): AppConfig {
  try {
    if (fs.existsSync(CONFIG_PATH)) {
      const raw = fs.readFileSync(CONFIG_PATH, 'utf-8');
      const parsed = JSON.parse(raw);
      return {
        ...DEFAULT_CONFIG,
        ...parsed,
        models: { ...DEFAULT_MODELS, ...parsed.models },
        scriptPath: parsed.scriptPath || resolveScriptPath(),
      };
    }
  } catch {
    // Fall through to defaults
  }

  // If no JSON config, try to import from existing bash config
  const config = { ...DEFAULT_CONFIG, scriptPath: resolveScriptPath() };

  if (fs.existsSync(BASH_CONFIG_PATH)) {
    try {
      const bashContent = fs.readFileSync(BASH_CONFIG_PATH, 'utf-8');
      const extractVar = (name: string): string | undefined => {
        const match = bashContent.match(new RegExp(`^${name}="?([^"\\n]*)"?`, 'm'));
        return match?.[1];
      };

      const wsRoot = extractVar('WORKSPACE_ROOT');
      if (wsRoot && !wsRoot.startsWith('$')) config.workspaceRoot = wsRoot;

      const maxRetries = extractVar('MAX_RETRIES');
      if (maxRetries) config.maxRetries = parseInt(maxRetries, 10) || 3;

      const sound = extractVar('NOTIFICATION_SOUND');
      if (sound) config.notificationSound = sound === 'true';
    } catch {
      // Ignore parse errors
    }
  }

  saveConfig(config);
  return config;
}

export function saveConfig(config: AppConfig): void {
  fs.writeFileSync(CONFIG_PATH, JSON.stringify(config, null, 2), 'utf-8');

  // Also regenerate bash config for CLI compatibility
  generateBashConfig(config);
}

function generateBashConfig(config: AppConfig): void {
  const bashContent = `#!/usr/bin/env bash
# Auto-generated by CodeLoop — edit in the app UI instead.

WORKSPACE_ROOT="${config.workspaceRoot}"

MODEL_PLAN="${config.models.modelPlan}"
MODEL_IMPLEMENT="${config.models.modelImplement}"
MODEL_REVIEW="${config.models.modelReview}"
MODEL_FIX="${config.models.modelFix}"
MODEL_COMMIT="${config.models.modelCommit}"
MODEL_PR="${config.models.modelPr}"
MODEL_BRANCH="${config.models.modelBranch}"

if ! declare -p POST_CLONE_COMMANDS >/dev/null 2>&1; then
  POST_CLONE_COMMANDS=(${config.postCloneCommands.map((c) => `"${c}"`).join(' ')})
fi

MAX_RETRIES=${config.maxRetries}
if ! declare -p RETRY_DELAYS >/dev/null 2>&1; then
  RETRY_DELAYS=(${config.retryDelays.join(' ')})
fi

NOTIFICATION_SOUND=${config.notificationSound}
`;

  try {
    fs.writeFileSync(BASH_CONFIG_PATH, bashContent, { mode: 0o600 });
  } catch {
    // Non-fatal — bash config is a convenience
  }
}

export function addRecentRepo(config: AppConfig, repoPath: string): AppConfig {
  const repos = config.recentRepos.filter((r) => r !== repoPath);
  repos.unshift(repoPath);
  if (repos.length > 20) repos.length = 20;
  const updated = { ...config, recentRepos: repos };
  saveConfig(updated);
  return updated;
}
