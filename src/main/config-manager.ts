import fs from 'fs';
import path from 'path';
import os from 'os';
import { PREDEFINED_WORKFLOWS } from '../shared/types';
import type { AppConfig, ModelConfig, WorkflowDefinition } from '../shared/types';

const CONFIG_PATH = path.join(os.homedir(), '.opencode-loop-app.json');
const BASH_CONFIG_PATH = path.join(os.homedir(), '.opencode-loop.conf');

const DEFAULT_MODELS: ModelConfig = {
  modelPlan: 'github-copilot/claude-opus-4.6',
  modelImplement: 'github-copilot/claude-sonnet-4.6',
  modelReview: 'github-copilot/gpt-5.2-codex',
  modelFix: 'github-copilot/claude-sonnet-4.6',
  modelCommit: 'github-copilot/gemini-3-flash-preview',
  modelPr: 'github-copilot/gemini-3-flash-preview',
  modelBranch: 'github-copilot/gemini-3-flash-preview',
};

const DEFAULT_WORKFLOW_ID = PREDEFINED_WORKFLOWS[0].id;

const DEFAULT_CONFIG: AppConfig = {
  workspaceRoot: path.join(os.homedir(), 'codeloop-workspaces'),
  defaultWorkflowId: DEFAULT_WORKFLOW_ID,
  models: { ...DEFAULT_MODELS },
  lastModelOverrides: {},
  postCloneCommands: ['pnpm i'],
  maxRetries: 3,
  retryDelays: [10, 30, 60],
  notificationSound: true,
  autoApproveExternalDirectory: false,
  launchChecksPassed: false,
  recentRepos: [],
  branchPrefix: 'codeloop',
  skipPr: false,
};

export function listPredefinedWorkflows(): WorkflowDefinition[] {
  return PREDEFINED_WORKFLOWS.map((workflow) => ({ ...workflow }));
}

export function getWorkflowById(workflowId: string): WorkflowDefinition {
  return PREDEFINED_WORKFLOWS.find((workflow) => workflow.id === workflowId) ?? PREDEFINED_WORKFLOWS[0];
}

export function resolveScriptPath(workflowId: string): string {
  const workflow = getWorkflowById(workflowId);
  const scriptFile = workflow.scriptFile;
  const candidates = [
    path.resolve(__dirname, '../../scripts', scriptFile),
    path.resolve(__dirname, '../../../scripts', scriptFile),
    path.resolve(process.cwd(), 'scripts', scriptFile),
    path.resolve(process.resourcesPath, 'scripts', scriptFile),
  ];

  if (workflow.id === 'development-auto-pr') {
    candidates.push(
      path.resolve(__dirname, '../../opencode-loop.sh'),
      path.resolve(__dirname, '../../../opencode-loop.sh'),
      path.resolve(process.cwd(), 'opencode-loop.sh'),
      path.resolve(process.resourcesPath, 'opencode-loop.sh')
    );
  }

  for (const p of candidates) {
    if (fs.existsSync(p)) return p;
  }

  return path.resolve(process.cwd(), 'scripts', scriptFile);
}

export function loadConfig(): AppConfig {
  try {
    if (fs.existsSync(CONFIG_PATH)) {
      const raw = fs.readFileSync(CONFIG_PATH, 'utf-8');
      const parsed = JSON.parse(raw);
      const parsedWithoutScriptPath = { ...(parsed as Record<string, unknown>) };
      delete parsedWithoutScriptPath.scriptPath;
      const defaultWorkflowId = String(parsedWithoutScriptPath.defaultWorkflowId ?? DEFAULT_WORKFLOW_ID);
      const safeWorkflowId = PREDEFINED_WORKFLOWS.some((workflow) => workflow.id === defaultWorkflowId)
        ? defaultWorkflowId
        : DEFAULT_WORKFLOW_ID;
      return {
        ...DEFAULT_CONFIG,
        ...parsedWithoutScriptPath,
        defaultWorkflowId: safeWorkflowId,
        models: { ...DEFAULT_MODELS, ...(parsedWithoutScriptPath.models as Partial<ModelConfig> | undefined) },
        lastModelOverrides: {
          ...(parsedWithoutScriptPath.lastModelOverrides as Partial<ModelConfig> | undefined),
        },
      };
    }
  } catch {
    // Fall through to defaults
  }

  // If no JSON config, try to import from existing bash config
  const config = { ...DEFAULT_CONFIG };

  if (fs.existsSync(BASH_CONFIG_PATH)) {
    try {
      const bashContent = fs.readFileSync(BASH_CONFIG_PATH, 'utf-8');
      const extractVar = (name: string): string | undefined => {
        const match = bashContent.match(new RegExp(`^${name}="?([^"\\n]*)"?`, 'm'));
        return match?.[1];
      };

      const wsRoot = extractVar('WORKSPACE_ROOT');
      if (wsRoot && !wsRoot.startsWith('$')) config.workspaceRoot = wsRoot;

      const maxRetries = extractVar('MAX_RETRIES');
      if (maxRetries) config.maxRetries = parseInt(maxRetries, 10) || 3;

      const sound = extractVar('NOTIFICATION_SOUND');
      if (sound) config.notificationSound = sound === 'true';
    } catch {
      // Ignore parse errors
    }
  }

  saveConfig(config);
  return config;
}

export function saveConfig(config: AppConfig): void {
  const safeConfig: AppConfig = {
    ...config,
    defaultWorkflowId: PREDEFINED_WORKFLOWS.some((workflow) => workflow.id === config.defaultWorkflowId)
      ? config.defaultWorkflowId
      : DEFAULT_WORKFLOW_ID,
  };

  fs.writeFileSync(CONFIG_PATH, JSON.stringify(safeConfig, null, 2), 'utf-8');

  // Also regenerate bash config for CLI compatibility
  generateBashConfig(safeConfig);
}

function generateBashConfig(config: AppConfig): void {
  const bashContent = `#!/usr/bin/env bash
# Auto-generated by CodeLoop — edit in the app UI instead.

WORKSPACE_ROOT="${config.workspaceRoot}"

MODEL_PLAN="${config.models.modelPlan}"
MODEL_IMPLEMENT="${config.models.modelImplement}"
MODEL_REVIEW="${config.models.modelReview}"
MODEL_FIX="${config.models.modelFix}"
MODEL_COMMIT="${config.models.modelCommit}"
MODEL_PR="${config.models.modelPr}"
MODEL_BRANCH="${config.models.modelBranch}"

if ! declare -p POST_CLONE_COMMANDS >/dev/null 2>&1; then
  POST_CLONE_COMMANDS=(${config.postCloneCommands.map((c) => `"${c}"`).join(' ')})
fi

MAX_RETRIES=${config.maxRetries}
if ! declare -p RETRY_DELAYS >/dev/null 2>&1; then
  RETRY_DELAYS=(${config.retryDelays.join(' ')})
fi

NOTIFICATION_SOUND=${config.notificationSound}
AUTO_APPROVE_EXTERNAL_DIRECTORY=${config.autoApproveExternalDirectory}
BRANCH_PREFIX="${config.branchPrefix}"
SKIP_PR=${config.skipPr}
`;

  try {
    fs.writeFileSync(BASH_CONFIG_PATH, bashContent, { mode: 0o600 });
  } catch {
    // Non-fatal — bash config is a convenience
  }
}

export function addRecentRepo(config: AppConfig, repoPath: string): AppConfig {
  const repos = config.recentRepos.filter((r) => r !== repoPath);
  repos.unshift(repoPath);
  if (repos.length > 20) repos.length = 20;
  const updated = { ...config, recentRepos: repos };
  saveConfig(updated);
  return updated;
}
